---
description: 資料庫互動規則，使用非同步函式庫進行資料庫操作的特定規則
globs: "**/db/*.py", "**/models/*.py", "**/crud/*.py", "**/database.py"
priority: high
category: database
alwaysApply: true
dependencies: ["performance-optimization-rules.mdc", "error-handling-rules.mdc"]
---

# 資料庫互動規則

## 核心原則
- **非同步優先**: 所有資料庫操作必須使用非同步函數
- **連接池管理**: 正確管理資料庫連接池
- **事務安全**: 確保資料庫事務的 ACID 特性
- **錯誤處理**: 妥善處理資料庫連接和查詢錯誤

## 必須使用的函式庫

### 推薦的非同步資料庫函式庫
```python
# ✅ PostgreSQL
import asyncpg
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine

# ✅ MySQL
import aiomysql
from sqlalchemy.ext.asyncio import AsyncSession

# ✅ SQLite (開發環境)
import aiosqlite
```

## 資料庫設定模式

### 非同步引擎設定
```python
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker
from contextlib import asynccontextmanager

# ✅ 正確的非同步引擎設定
DATABASE_URL = "postgresql+asyncpg://user:password@localhost/dbname"

engine = create_async_engine(
    DATABASE_URL,
    echo=True,  # 開發環境
    pool_size=20,
    max_overflow=0,
    pool_pre_ping=True,  # 檢查連接是否有效
    pool_recycle=3600,   # 1小時後重新建立連接
)

AsyncSessionLocal = sessionmaker(
    engine, class_=AsyncSession, expire_on_commit=False
)
```

### 依賴注入模式
```python
# ✅ FastAPI 依賴注入
async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """資料庫會話依賴注入"""
    async with AsyncSessionLocal() as session:
        try:
            yield session
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()

# ✅ 使用方式
@app.get("/users/{user_id}")
async def get_user(
    user_id: int, 
    db: AsyncSession = Depends(get_db)
) -> UserResponse:
    return await get_user_by_id(db, user_id)
```

## CRUD 操作模式

### 基礎 CRUD 模式
```python
# ✅ 非同步 CRUD 操作
async def create_user(db: AsyncSession, user: UserCreate) -> User:
    """建立使用者"""
    db_user = User(**user.dict())
    db.add(db_user)
    await db.commit()
    await db.refresh(db_user)
    return db_user

async def get_user_by_id(db: AsyncSession, user_id: int) -> Optional[User]:
    """根據 ID 取得使用者"""
    result = await db.execute(
        select(User).where(User.id == user_id)
    )
    return result.scalar_one_or_none()

async def update_user(
    db: AsyncSession, user_id: int, user_update: UserUpdate
) -> Optional[User]:
    """更新使用者"""
    result = await db.execute(
        select(User).where(User.id == user_id)
    )
    db_user = result.scalar_one_or_none()
    
    if not db_user:
        return None
    
    for field, value in user_update.dict(exclude_unset=True).items():
        setattr(db_user, field, value)
    
    await db.commit()
    await db.refresh(db_user)
    return db_user

async def delete_user(db: AsyncSession, user_id: int) -> bool:
    """刪除使用者"""
    result = await db.execute(
        select(User).where(User.id == user_id)
    )
    db_user = result.scalar_one_or_none()
    
    if not db_user:
        return False
    
    await db.delete(db_user)
    await db.commit()
    return True
```

### 批次操作
```python
# ✅ 批次插入
async def bulk_create_users(
    db: AsyncSession, users: List[UserCreate]
) -> List[User]:
    """批次建立使用者"""
    db_users = [User(**user.dict()) for user in users]
    db.add_all(db_users)
    await db.commit()
    
    for user in db_users:
        await db.refresh(user)
    
    return db_users

# ✅ 批次更新
async def bulk_update_users(
    db: AsyncSession, updates: List[Tuple[int, UserUpdate]]
) -> List[User]:
    """批次更新使用者"""
    updated_users = []
    
    for user_id, user_update in updates:
        result = await db.execute(
            select(User).where(User.id == user_id)
        )
        db_user = result.scalar_one_or_none()
        
        if db_user:
            for field, value in user_update.dict(exclude_unset=True).items():
                setattr(db_user, field, value)
            updated_users.append(db_user)
    
    await db.commit()
    
    for user in updated_users:
        await db.refresh(user)
    
    return updated_users
```

## 事務管理

### 明確事務控制
```python
# ✅ 明確事務管理
async def transfer_funds(
    db: AsyncSession, 
    from_account_id: int, 
    to_account_id: int, 
    amount: Decimal
) -> bool:
    """轉帳操作 - 需要事務保證"""
    async with db.begin():
        # 檢查來源帳戶餘額
        from_account = await get_account_by_id(db, from_account_id)
        if not from_account or from_account.balance < amount:
            raise ValueError("餘額不足")
        
        # 檢查目標帳戶存在
        to_account = await get_account_by_id(db, to_account_id)
        if not to_account:
            raise ValueError("目標帳戶不存在")
        
        # 執行轉帳
        from_account.balance -= amount
        to_account.balance += amount
        
        # 記錄交易
        transaction = Transaction(
            from_account_id=from_account_id,
            to_account_id=to_account_id,
            amount=amount,
            type="transfer"
        )
        db.add(transaction)
    
    return True
```

### 嵌套事務
```python
# ✅ 嵌套事務（保存點）
async def complex_business_operation(db: AsyncSession) -> None:
    """複雜業務操作，使用保存點"""
    async with db.begin():
        # 主要操作
        user = await create_user(db, user_data)
        
        # 嵌套事務
        async with db.begin_nested():
            try:
                await create_user_profile(db, user.id, profile_data)
                await send_welcome_email(user.email)
            except Exception:
                # 回滾到保存點，但不影響主事務
                raise
        
        # 繼續主要操作
        await log_user_creation(db, user.id)
```

## 查詢最佳化

### 延遲載入和預載入
```python
# ✅ 預載入關聯資料
async def get_user_with_posts(
    db: AsyncSession, user_id: int
) -> Optional[User]:
    """取得使用者及其文章（預載入）"""
    result = await db.execute(
        select(User)
        .options(selectinload(User.posts))
        .where(User.id == user_id)
    )
    return result.scalar_one_or_none()

# ✅ 分頁查詢
async def get_users_paginated(
    db: AsyncSession, 
    skip: int = 0, 
    limit: int = 100
) -> List[User]:
    """分頁取得使用者列表"""
    result = await db.execute(
        select(User)
        .offset(skip)
        .limit(limit)
        .order_by(User.created_at.desc())
    )
    return result.scalars().all()
```

### 原生 SQL 查詢
```python
# ✅ 複雜查詢使用原生 SQL
async def get_user_statistics(db: AsyncSession) -> Dict[str, Any]:
    """使用原生 SQL 取得統計資料"""
    query = text("""
        SELECT 
            COUNT(*) as total_users,
            COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '30 days') as new_users,
            AVG(EXTRACT(YEAR FROM AGE(birth_date))) as avg_age
        FROM users
        WHERE deleted_at IS NULL
    """)
    
    result = await db.execute(query)
    row = result.fetchone()
    
    return {
        "total_users": row.total_users,
        "new_users": row.new_users,
        "average_age": float(row.avg_age) if row.avg_age else 0
    }
```

## 錯誤處理

### 資料庫特定錯誤
```python
from sqlalchemy.exc import IntegrityError, SQLAlchemyError
from asyncpg.exceptions import UniqueViolationError

# ✅ 資料庫錯誤處理
async def create_user_safe(
    db: AsyncSession, user: UserCreate
) -> Union[User, str]:
    """安全建立使用者，處理重複錯誤"""
    try:
        db_user = User(**user.dict())
        db.add(db_user)
        await db.commit()
        await db.refresh(db_user)
        return db_user
    
    except IntegrityError as e:
        await db.rollback()
        if "unique constraint" in str(e).lower():
            return "使用者已存在"
        return "資料完整性錯誤"
    
    except SQLAlchemyError as e:
        await db.rollback()
        logger.error(f"資料庫錯誤: {e}")
        return "資料庫操作失敗"
    
    except Exception as e:
        await db.rollback()
        logger.error(f"未預期錯誤: {e}")
        return "系統錯誤"
```

## 連接池監控

### 健康檢查
```python
# ✅ 資料庫健康檢查
async def check_database_health(db: AsyncSession) -> bool:
    """檢查資料庫連接健康狀態"""
    try:
        await db.execute(text("SELECT 1"))
        return True
    except Exception as e:
        logger.error(f"資料庫健康檢查失敗: {e}")
        return False

# ✅ 連接池狀態監控
def get_pool_status():
    """取得連接池狀態"""
    pool = engine.pool
    return {
        "size": pool.size(),
        "checked_in": pool.checkedin(),
        "checked_out": pool.checkedout(),
        "overflow": pool.overflow(),
        "invalid": pool.invalid()
    }
```

## 禁止的操作

### ❌ 絕對不要使用
```python
# ❌ 同步資料庫操作
def sync_get_user(user_id: int):
    # 絕對不要在非同步應用中使用同步操作
    pass

# ❌ 不正確的連接管理
def bad_connection():
    # 不要手動管理連接
    conn = asyncpg.connect()
    # 忘記關閉連接
    pass

# ❌ SQL 注入風險
async def vulnerable_query(db: AsyncSession, user_input: str):
    # 絕對不要直接拼接 SQL
    query = f"SELECT * FROM users WHERE name = '{user_input}'"
    await db.execute(text(query))
```