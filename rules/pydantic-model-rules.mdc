---
description: 建立 Pydantic 模型的特定規則，專注於版本控制和專案內使用
globs: "**/models/*.py", "**/schemas/*.py", "**/dto/*.py"
priority: high
category: pydantic
alwaysApply: true
dependencies: ["python-general-principles.mdc", "error-handling-rules.mdc"]
---

# Pydantic 模型規則

## 核心原則
- **類型安全**: 所有函數簽名使用類型提示，優先使用 Pydantic 模型而非原始字典進行輸入驗證
- **版本一致**: 使用 Pydantic v2
- **一致性**: 使用 Pydantic 的 BaseModel 進行一致的輸入/輸出驗證和回應模式
- **效能優化**: 配置模型以獲得最佳效能

## 基本模型結構

### 標準模型定義
```python
from pydantic import BaseModel, Field, validator
from typing import Optional, List
from datetime import datetime

# ✅ 基本模型結構
class UserBase(BaseModel):
    """使用者基礎模型"""
    email: str = Field(..., description="使用者電子郵件", example="user@example.com")
    name: str = Field(..., min_length=2, max_length=100, description="使用者姓名")
    is_active: bool = Field(default=True, description="帳戶是否啟用")

class UserCreate(UserBase):
    """建立使用者模型"""
    password: str = Field(..., min_length=8, description="使用者密碼")
    
    @validator('password')
    def validate_password(cls, v):
        """驗證密碼強度"""
        if not any(c.isupper() for c in v):
            raise ValueError('密碼必須包含至少一個大寫字母')
        if not any(c.isdigit() for c in v):
            raise ValueError('密碼必須包含至少一個數字')
        return v

class UserResponse(UserBase):
    """使用者回應模型"""
    id: int = Field(..., description="使用者ID")
    created_at: datetime = Field(..., description="建立時間")
    updated_at: Optional[datetime] = Field(None, description="更新時間")
    
    class Config:
        orm_mode = True
        allow_population_by_field_name = True
```

### 枚舉類型定義
```python
from enum import Enum

# ✅ 字串枚舉
class UserStatus(str, Enum):
    """使用者狀態枚舉"""
    ACTIVE = "active"
    INACTIVE = "inactive"
    PENDING = "pending"
    SUSPENDED = "suspended"

class FileFormat(str, Enum):
    """檔案格式枚舉"""
    DICOM = "dicom"
    NIFTI = "nifti"
    JPEG = "jpeg"
    PNG = "png"

# ✅ 在模型中使用枚舉
class FileInfo(BaseModel):
    """檔案資訊模型"""
    filename: str = Field(..., description="檔案名稱")
    format: FileFormat = Field(..., description="檔案格式")
    size: int = Field(..., ge=0, description="檔案大小（位元組）")
    status: UserStatus = Field(default=UserStatus.ACTIVE, description="檔案狀態")
```

## 驗證器模式

### 欄位驗證器
```python
from pydantic import validator, EmailStr
import re

class UserCreateAdvanced(BaseModel):
    """進階使用者建立模型"""
    email: EmailStr = Field(..., description="使用者電子郵件")
    username: str = Field(..., min_length=3, max_length=20, description="使用者名稱")
    password: str = Field(..., min_length=8, description="密碼")
    age: Optional[int] = Field(None, ge=0, le=150, description="年齡")
    phone: Optional[str] = Field(None, description="電話號碼")
    
    @validator('username')
    def validate_username(cls, v):
        """驗證使用者名稱格式"""
        if not re.match(r'^[a-zA-Z0-9_]+$', v):
            raise ValueError('使用者名稱只能包含字母、數字和底線')
        return v.lower()
    
    @validator('phone')
    def validate_phone(cls, v):
        """驗證電話號碼格式"""
        if v is None:
            return v
        
        # 移除所有非數字字符
        phone_digits = re.sub(r'\D', '', v)
        
        if not re.match(r'^09\d{8}$', phone_digits):
            raise ValueError('請輸入有效的台灣手機號碼')
        
        return phone_digits
```

### 根驗證器
```python
from pydantic import root_validator

class DateRangeFilter(BaseModel):
    """日期範圍過濾器"""
    start_date: Optional[datetime] = Field(None, description="開始日期")
    end_date: Optional[datetime] = Field(None, description="結束日期")
    days_ago: Optional[int] = Field(None, ge=0, description="幾天前")
    
    @root_validator
    def validate_date_range(cls, values):
        """驗證日期範圍邏輯"""
        start_date = values.get('start_date')
        end_date = values.get('end_date')
        days_ago = values.get('days_ago')
        
        # 檢查互斥條件
        if days_ago is not None and (start_date is not None or end_date is not None):
            raise ValueError('days_ago 不能與 start_date 或 end_date 同時使用')
        
        if start_date and end_date and start_date >= end_date:
            raise ValueError('開始日期必須早於結束日期')
        
        return values
```

## 嵌套模型

### 複雜嵌套結構
```python
from typing import Dict, Any

class Address(BaseModel):
    """地址模型"""
    street: str = Field(..., description="街道地址")
    city: str = Field(..., description="城市")
    postal_code: str = Field(..., description="郵政編碼")
    country: str = Field(default="台灣", description="國家")
    
    @validator('postal_code')
    def validate_postal_code(cls, v):
        """驗證郵政編碼"""
        if not re.match(r'^\d{3,5}$', v):
            raise ValueError('郵政編碼格式不正確')
        return v

class ContactInfo(BaseModel):
    """聯絡資訊模型"""
    email: EmailStr = Field(..., description="電子郵件")
    phone: Optional[str] = Field(None, description="電話號碼")
    address: Optional[Address] = Field(None, description="地址")

class UserProfile(BaseModel):
    """使用者個人資料模型"""
    user_id: int = Field(..., description="使用者ID")
    bio: Optional[str] = Field(None, max_length=500, description="個人簡介")
    contact_info: ContactInfo = Field(..., description="聯絡資訊")
    preferences: Dict[str, Any] = Field(default_factory=dict, description="使用者偏好設定")
    tags: List[str] = Field(default_factory=list, description="使用者標籤")
    
    class Config:
        orm_mode = True
```

## 回應模型模式

### 分頁回應模型
```python
from typing import Generic, TypeVar

T = TypeVar('T')

class PaginatedResponse(BaseModel, Generic[T]):
    """分頁回應模型"""
    items: List[T] = Field(..., description="資料項目")
    total: int = Field(..., description="總數量")
    page: int = Field(..., description="當前頁數")
    size: int = Field(..., description="每頁大小")
    has_next: bool = Field(..., description="是否有下一頁")
    has_prev: bool = Field(..., description="是否有上一頁")

class ApiResponse(BaseModel, Generic[T]):
    """統一 API 回應格式"""
    success: bool = Field(..., description="請求是否成功")
    message: Optional[str] = Field(None, description="回應訊息")
    data: Optional[T] = Field(None, description="回應資料")
    errors: Optional[List[str]] = Field(None, description="錯誤訊息列表")
    
    @classmethod
    def success_response(cls, data: T, message: str = "操作成功"):
        """建立成功回應"""
        return cls(success=True, message=message, data=data)
    
    @classmethod
    def error_response(cls, message: str, errors: Optional[List[str]] = None):
        """建立錯誤回應"""
        return cls(success=False, message=message, errors=errors or [])
```

## 效能最佳化配置

### 高效能模型配置
```python
import orjson
from pydantic import BaseModel

class OptimizedModel(BaseModel):
    """最佳化的模型基類"""
    
    class Config:
        # JSON 序列化最佳化
        json_loads = orjson.loads
        json_dumps = orjson.dumps
        
        # 效能最佳化
        allow_reuse = True              # 重用驗證器
        validate_assignment = False     # 關閉賦值驗證
        use_enum_values = True          # 使用枚舉值
        
        # ORM 支援
        orm_mode = True
        allow_population_by_field_name = True
        
        # 其他最佳化
        extra = "forbid"                # 禁止額外欄位
```

## 設定模型

### 應用程式設定
```python
from pydantic import BaseSettings

class AppSettings(BaseSettings):
    """應用程式設定"""
    app_name: str = Field(default="醫學影像處理API", description="應用程式名稱")
    version: str = Field(default="1.0.0", description="版本號")
    debug: bool = Field(default=False, description="除錯模式")
    
    # 資料庫設定
    database_url: str = Field(..., description="資料庫連接URL")
    
    # Redis 設定
    redis_url: str = Field(default="redis://localhost:6379", description="Redis連接URL")
    
    # 安全設定
    secret_key: str = Field(..., description="密鑰")
    
    # 檔案設定
    upload_dir: str = Field(default="./uploads", description="上傳目錄")
    max_file_size: int = Field(default=100*1024*1024, description="最大檔案大小")
    
    class Config:
        env_file = ".env"
        
    @validator('max_file_size')
    def validate_max_file_size(cls, v):
        """驗證最大檔案大小"""
        if v <= 0:
            raise ValueError('最大檔案大小必須大於0')
        return v
```

## 禁止的模式

### ❌ 絕對不要使用
```python
# ❌ 使用原始字典而非 Pydantic 模型
def process_user_data(user_data: dict):  # 應該使用 UserCreate
    pass

# ❌ 沒有類型提示
class BadModel(BaseModel):
    name = Field(...)  # 缺少類型提示
    age = Field(...)   # 缺少類型提示

# ❌ 不適當的驗證器
class BadValidation(BaseModel):
    email: str
    
    @validator('email')
    def validate_email(cls, v):
        # 不要重新實作電子郵件驗證，使用 EmailStr
        if '@' not in v:
            raise ValueError('無效的電子郵件')
        return v
```