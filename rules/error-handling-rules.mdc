---
description: Python 和 FastAPI 應用程式中處理錯誤和邊緣情況的指導方針
globs: "**/*.py"
priority: critical
category: error-handling
alwaysApply: true
dependencies: ["python-general-principles.mdc", "fastapi-application-rules.mdc"]
---

# 錯誤處理規則

## 核心原則
- **錯誤優先**: 在函數開始處處理錯誤和邊緣情況
- **早期返回**: 使用早期返回避免深度嵌套的 if 語句
- **快樂路徑最後**: 將正常執行路徑放在函數最後以提高可讀性
- **避免不必要的 else**: 使用 if-return 模式而不是 else 語句
- **守衛子句**: 使用守衛子句早期處理前置條件和無效狀態

## 錯誤處理模式

### 早期返回模式
```python
# ✅ 正確：早期返回，扁平結構
async def process_user_data(user_id: int, data: dict) -> UserResponse:
    """處理使用者資料 - 早期返回模式"""
    # 守衛子句：檢查輸入
    if not user_id or user_id <= 0:
        raise ValueError("無效的使用者 ID")
    
    if not data:
        raise ValueError("資料不能為空")
    
    if "email" not in data:
        raise ValueError("缺少必要欄位：email")
    
    # 檢查使用者存在性
    user = await get_user_by_id(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="使用者不存在")
    
    # 檢查權限
    if not user.is_active:
        raise HTTPException(status_code=403, detail="使用者帳戶已停用")
    
    # 快樂路徑：正常處理邏輯
    updated_user = await update_user(user_id, data)
    return UserResponse.from_orm(updated_user)
```

### 自訂錯誤類型
```python
# ✅ 自訂錯誤類型
class UserError(Exception):
    """使用者相關錯誤基類"""
    pass

class UserNotFoundError(UserError):
    """使用者不存在錯誤"""
    def __init__(self, user_id: int):
        self.user_id = user_id
        super().__init__(f"使用者 {user_id} 不存在")

class ValidationError(UserError):
    """資料驗證錯誤"""
    def __init__(self, field: str, message: str):
        self.field = field
        self.message = message
        super().__init__(f"驗證錯誤 {field}: {message}")
```

### 錯誤工廠模式
```python
# ✅ 錯誤工廠
class ErrorFactory:
    """統一錯誤建立工廠"""
    
    @staticmethod
    def user_not_found(user_id: int) -> HTTPException:
        return HTTPException(
            status_code=404,
            detail={
                "error": "USER_NOT_FOUND",
                "message": f"使用者 {user_id} 不存在",
                "user_id": user_id
            }
        )
    
    @staticmethod
    def validation_error(field: str, message: str) -> HTTPException:
        return HTTPException(
            status_code=422,
            detail={
                "error": "VALIDATION_ERROR",
                "message": f"欄位 {field} 驗證失敗: {message}",
                "field": field
            }
        )
```

## FastAPI 錯誤處理

### HTTP 異常處理
```python
from fastapi import HTTPException, status

# ✅ 標準 HTTP 錯誤
async def create_user(user_data: UserCreate) -> User:
    """建立使用者"""
    # 輸入驗證
    if not user_data.email:
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail="電子郵件為必填欄位"
        )
    
    # 檢查重複
    existing_user = await get_user_by_email(user_data.email)
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="電子郵件已被使用"
        )
    
    # 建立使用者
    try:
        return await create_user_in_db(user_data)
    except DatabaseError as e:
        logger.error(f"資料庫錯誤: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="伺服器內部錯誤"
        )
```

### 全域錯誤處理中介軟體
```python
from fastapi import Request
from fastapi.responses import JSONResponse
import traceback
import logging

logger = logging.getLogger(__name__)

# ✅ 全域錯誤處理中介軟體
@app.middleware("http")
async def error_handling_middleware(request: Request, call_next):
    """全域錯誤處理中介軟體"""
    try:
        response = await call_next(request)
        return response
    
    except HTTPException:
        # FastAPI 會自動處理 HTTPException
        raise
    
    except ValidationError as e:
        logger.warning(f"驗證錯誤: {e}")
        return JSONResponse(
            status_code=422,
            content={
                "error": "VALIDATION_ERROR",
                "message": str(e),
                "path": request.url.path
            }
        )
    
    except Exception as e:
        logger.error(
            f"未處理的錯誤: {e}\n"
            f"路徑: {request.url.path}\n"
            f"方法: {request.method}\n"
            f"追蹤: {traceback.format_exc()}"
        )
        
        return JSONResponse(
            status_code=500,
            content={
                "error": "INTERNAL_SERVER_ERROR",
                "message": "伺服器內部錯誤",
                "path": request.url.path
            }
        )
```

## 日誌記錄

### 結構化日誌
```python
import logging
import json
from datetime import datetime

# ✅ 結構化日誌記錄器
class StructuredLogger:
    """結構化日誌記錄器"""
    
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
    
    def error(self, message: str, **kwargs):
        """記錄錯誤"""
        log_data = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": "ERROR",
            "message": message,
            **kwargs
        }
        self.logger.error(json.dumps(log_data, ensure_ascii=False))
```

## 禁止的錯誤處理模式

### ❌ 絕對不要使用
```python
# ❌ 忽略錯誤
try:
    risky_operation()
except:
    pass  # 絕對不要忽略錯誤

# ❌ 捕獲所有異常而不處理
try:
    some_operation()
except Exception:
    print("出錯了")  # 不提供有用資訊

# ❌ 不明確的錯誤訊息
raise Exception("出錯了")  # 不提供足夠資訊
```