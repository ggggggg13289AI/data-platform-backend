---
description: FastAPI 應用程式結構和主應用程式檔案設定的特定指導方針
globs: "**/main.py", "**/app.py", "**/server.py"
priority: high
category: fastapi
alwaysApply: true
dependencies: ["python-general-principles.mdc", "error-handling-rules.mdc", "performance-optimization-rules.mdc"]
---

# FastAPI 應用程式規則

## 核心原則
- **函數式組件**: 使用純函數和 Pydantic 模型進行輸入驗證和回應模式
- **聲明式路由**: 使用清晰的回傳類型註解定義路由
- **生命週期管理**: 使用 lifespan 上下文管理器而非事件處理器
- **中介軟體優先**: 使用中介軟體處理日誌、錯誤監控和效能最佳化

## 應用程式結構

### 基本應用程式設定
```python
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import logging

# ✅ 使用 lifespan 管理應用程式生命週期
@asynccontextmanager
async def lifespan(app: FastAPI):
    """應用程式生命週期管理"""
    # 啟動時執行
    logger.info("應用程式啟動")
    await setup_database()
    await setup_redis()
    
    yield  # 應用程式運行
    
    # 關閉時執行
    logger.info("應用程式關閉")
    await cleanup_database()
    await cleanup_redis()

# ✅ 正確的應用程式初始化
app = FastAPI(
    title="醫學影像處理 API",
    description="DICOM 到 NIfTI 轉換和影像處理服務",
    version="2.2.0",
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json",
    lifespan=lifespan  # 使用 lifespan 而非事件處理器
)
```

### 中介軟體設定
```python
# ✅ CORS 中介軟體
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "https://yourdomain.com"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ✅ 自訂中介軟體
@app.middleware("http")
async def logging_middleware(request: Request, call_next):
    """請求日誌中介軟體"""
    start_time = time.time()
    
    # 記錄請求
    logger.info(
        f"請求開始: {request.method} {request.url.path}",
        method=request.method,
        path=request.url.path,
        client_ip=request.client.host
    )
    
    # 執行請求
    response = await call_next(request)
    
    # 記錄回應
    process_time = time.time() - start_time
    logger.info(
        f"請求完成: {response.status_code} ({process_time:.3f}s)",
        status_code=response.status_code,
        process_time=process_time
    )
    
    response.headers["X-Process-Time"] = str(process_time)
    return response

# ✅ 安全中介軟體
@app.middleware("http")
async def security_middleware(request: Request, call_next):
    """安全標頭中介軟體"""
    response = await call_next(request)
    
    # 添加安全標頭
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["X-XSS-Protection"] = "1; mode=block"
    response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
    
    return response
```

### 路由組織
```python
from .routers import users, files, processing

# ✅ 路由註冊
app.include_router(
    users.router,
    prefix="/api/v1/users",
    tags=["使用者管理"]
)

app.include_router(
    files.router,
    prefix="/api/v1/files",
    tags=["檔案管理"]
)

app.include_router(
    processing.router,
    prefix="/api/v1/processing",
    tags=["影像處理"]
)

# ✅ 健康檢查端點
@app.get("/health", tags=["系統"])
async def health_check():
    """系統健康檢查"""
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "version": "2.2.0"
    }

# ✅ 根端點
@app.get("/", tags=["系統"])
async def root():
    """API 根端點"""
    return {
        "message": "醫學影像處理 API",
        "version": "2.2.0",
        "docs": "/docs"
    }
```

## 依賴注入

### 資料庫依賴
```python
from sqlalchemy.ext.asyncio import AsyncSession
from fastapi import Depends

# ✅ 資料庫會話依賴
async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """取得資料庫會話"""
    async with AsyncSessionLocal() as session:
        try:
            yield session
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()

# ✅ 使用依賴注入
@app.get("/users/{user_id}")
async def get_user(
    user_id: int,
    db: AsyncSession = Depends(get_db)
) -> UserResponse:
    """取得使用者資訊"""
    user = await get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(404, "使用者不存在")
    return UserResponse.from_orm(user)
```

### 認證依賴
```python
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi import Security

security = HTTPBearer()

# ✅ 認證依賴
async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Security(security),
    db: AsyncSession = Depends(get_db)
) -> User:
    """取得當前使用者"""
    token = credentials.credentials
    
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id = payload.get("sub")
        if user_id is None:
            raise HTTPException(401, "無效的認證令牌")
    except JWTError:
        raise HTTPException(401, "無效的認證令牌")
    
    user = await get_user_by_id(db, int(user_id))
    if not user:
        raise HTTPException(401, "使用者不存在")
    
    return user

# ✅ 使用認證依賴
@app.get("/profile")
async def get_profile(
    current_user: User = Depends(get_current_user)
) -> UserProfile:
    """取得使用者個人資料"""
    return await get_user_profile(current_user.id)
```

## 設定管理

### 環境設定
```python
from pydantic import BaseSettings
from typing import List

# ✅ 設定類別
class Settings(BaseSettings):
    """應用程式設定"""
    
    # 應用程式設定
    app_name: str = "醫學影像處理 API"
    app_version: str = "2.2.0"
    debug: bool = False
    
    # 資料庫設定
    database_url: str
    database_pool_size: int = 20
    database_max_overflow: int = 0
    
    # Redis 設定
    redis_url: str = "redis://localhost:6379"
    
    # JWT 設定
    secret_key: str
    algorithm: str = "HS256"
    access_token_expire_minutes: int = 30
    
    # CORS 設定
    allowed_origins: List[str] = ["http://localhost:3000"]
    
    # 檔案設定
    upload_dir: str = "./uploads"
    max_file_size: int = 100 * 1024 * 1024  # 100MB
    
    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

# ✅ 全域設定實例
settings = Settings()

# ✅ 設定依賴
def get_settings() -> Settings:
    """取得應用程式設定"""
    return settings
```

## 錯誤處理

### 全域異常處理器
```python
from fastapi.responses import JSONResponse

# ✅ 自訂異常處理器
@app.exception_handler(ValueError)
async def value_error_handler(request: Request, exc: ValueError):
    """值錯誤處理器"""
    return JSONResponse(
        status_code=400,
        content={
            "error": "VALUE_ERROR",
            "message": str(exc),
            "path": request.url.path
        }
    )

@app.exception_handler(404)
async def not_found_handler(request: Request, exc):
    """404 錯誤處理器"""
    return JSONResponse(
        status_code=404,
        content={
            "error": "NOT_FOUND",
            "message": "請求的資源不存在",
            "path": request.url.path
        }
    )
```

## 效能最佳化

### 快取中介軟體
```python
import redis.asyncio as redis
from fastapi import Request

# ✅ Redis 連接
redis_client = redis.from_url(settings.redis_url)

# ✅ 快取中介軟體
@app.middleware("http")
async def cache_middleware(request: Request, call_next):
    """快取中介軟體"""
    # 只快取 GET 請求
    if request.method != "GET":
        return await call_next(request)
    
    cache_key = f"cache:{request.url.path}:{str(request.query_params)}"
    
    # 檢查快取
    cached_response = await redis_client.get(cache_key)
    if cached_response:
        return JSONResponse(
            content=json.loads(cached_response),
            headers={"X-Cache": "HIT"}
        )
    
    # 執行請求
    response = await call_next(request)
    
    # 快取回應
    if response.status_code == 200:
        await redis_client.setex(
            cache_key,
            300,  # 5分鐘
            json.dumps(response.body.decode())
        )
        response.headers["X-Cache"] = "MISS"
    
    return response
```

## 禁止的模式

### ❌ 絕對不要使用
```python
# ❌ 使用事件處理器而非 lifespan
@app.on_event("startup")
async def startup_event():
    # 已棄用，使用 lifespan 代替
    pass

# ❌ 同步路由處理器（除非必要）
@app.get("/sync-endpoint")
def sync_handler():
    # 避免同步處理器，影響效能
    pass

# ❌ 全域變數管理狀態
global_state = {}  # 避免使用全域變數

# ❌ 硬編碼設定
DATABASE_URL = "postgresql://user:pass@localhost/db"  # 使用設定類別
```